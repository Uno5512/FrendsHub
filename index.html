<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P Social - –î–µ—Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–∞—è –ª–µ–Ω—Ç–∞</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        'rubik': ['Rubik', 'sans-serif'],
                    },
                    backgroundImage: {
                        'dot-grid': 'radial-gradient(circle, #e5e7eb 1px, transparent 1px)',
                    },
                    backgroundSize: {
                        '12px': '12px 12px',
                    },
                    backdropBlur: {
                        xs: '2px',
                    }
                }
            }
        }
    </script>
    <style>
        body {
            background-image: radial-gradient(circle, #e5e7eb 1px, transparent 1px);
            background-size: 12px 12px;
            background-color: #f8fafc;
        }
        
        .glass {
            background: rgba(255, 255, 255, 0.25);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .status-dot {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>
</head>
<body class="font-rubik min-h-screen">
    <div class="container mx-auto px-4 py-6 max-w-4xl">
        <!-- Header -->
        <div class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-800 mb-2">üåê P2P Social</h1>
            <p class="text-gray-600 mb-4">–î–µ—Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–∞—è –ª–µ–Ω—Ç–∞ –±–µ–∑ —Å–µ—Ä–≤–µ—Ä–æ–≤</p>
            <div class="flex items-center justify-center gap-3 text-sm text-gray-700">
                <div class="flex items-center gap-2">
                    <div class="w-2 h-2 rounded-full bg-red-500 status-dot" id="statusDot"></div>
                    <span id="statusText">–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ —Å–µ—Ç–∏...</span>
                </div>
                <span class="text-gray-500">|</span>
                <span id="peerCount">–ü–∏—Ä–æ–≤: 0</span>
                <span class="text-gray-500">|</span>
                <span id="postCount">–ü–æ—Å—Ç–æ–≤: 0</span>
            </div>
        </div>

        <!-- Create Post Form -->
        <div class="glass rounded-2xl p-6 mb-6">
            <h2 class="text-xl font-semibold text-gray-800 mb-4">–°–æ–∑–¥–∞—Ç—å —Å–æ–±—ã—Ç–∏–µ</h2>
            <div class="space-y-4">
                <input type="text" id="postTitle" 
                       placeholder="–ó–∞–≥–æ–ª–æ–≤–æ–∫ —Å–æ–±—ã—Ç–∏—è..." 
                       class="w-full px-4 py-3 rounded-xl border border-gray-200 focus:border-blue-400 focus:outline-none bg-white/70">
                
                <textarea id="postDescription" 
                          placeholder="–û–ø–∏—Å–∞–Ω–∏–µ —Å–æ–±—ã—Ç–∏—è..." 
                          rows="3"
                          class="w-full px-4 py-3 rounded-xl border border-gray-200 focus:border-blue-400 focus:outline-none bg-white/70 resize-none"></textarea>
                
                <input type="text" id="postTags" 
                       placeholder="–¢–µ–≥–∏ —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é (–∫–æ–Ω—Ü–µ—Ä—Ç, –º—É–∑—ã–∫–∞, —Ä–æ–∫)" 
                       class="w-full px-4 py-3 rounded-xl border border-gray-200 focus:border-blue-400 focus:outline-none bg-white/70">
                
                <textarea id="postContacts" 
                          placeholder="–í–∞—à–∏ –∫–æ–Ω—Ç–∞–∫—Ç—ã –∏ —Å—Å—ã–ª–∫–∏..." 
                          rows="2"
                          class="w-full px-4 py-3 rounded-xl border border-gray-200 focus:border-blue-400 focus:outline-none bg-white/70 resize-none"></textarea>
                
                <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                    <select id="postCity" class="px-4 py-3 rounded-xl border border-gray-200 focus:border-blue-400 focus:outline-none bg-white/70">
                        <option value="">–ì–æ—Ä–æ–¥</option>
                        <option value="moscow">–ú–æ—Å–∫–≤–∞</option>
                        <option value="spb">–°–ü–±</option>
                        <option value="ekb">–ï–∫–∞—Ç–µ—Ä–∏–Ω–±—É—Ä–≥</option>
                        <option value="nsk">–ù–æ–≤–æ—Å–∏–±–∏—Ä—Å–∫</option>
                        <option value="other">–î—Ä—É–≥–æ–π</option>
                    </select>
                    
                    <select id="postType" class="px-4 py-3 rounded-xl border border-gray-200 focus:border-blue-400 focus:outline-none bg-white/70">
                        <option value="event">–°–æ–±—ã—Ç–∏–µ</option>
                        <option value="meet">–í—Å—Ç—Ä–µ—á–∞</option>
                        <option value="help">–ü–æ–º–æ—â—å</option>
                        <option value="sale">–ü—Ä–æ–¥–∞–∂–∞</option>
                        <option value="other">–î—Ä—É–≥–æ–µ</option>
                    </select>
                    
                    <select id="postGender" class="px-4 py-3 rounded-xl border border-gray-200 focus:border-blue-400 focus:outline-none bg-white/70">
                        <option value="">–ü–æ–ª</option>
                        <option value="male">–ú—É–∂—Å–∫–æ–π</option>
                        <option value="female">–ñ–µ–Ω—Å–∫–∏–π</option>
                        <option value="any">–õ—é–±–æ–π</option>
                    </select>
                    
                    <select id="postAge" class="px-4 py-3 rounded-xl border border-gray-200 focus:border-blue-400 focus:outline-none bg-white/70">
                        <option value="">–í–æ–∑—Ä–∞—Å—Ç</option>
                        <option value="18-25">18-25</option>
                        <option value="26-35">26-35</option>
                        <option value="36-45">36-45</option>
                        <option value="46+">46+</option>
                    </select>
                </div>
                
                <button onclick="createPost()" 
                        class="w-full bg-gray-600 hover:bg-gray-700 text-white font-medium py-3 px-6 rounded-xl transition-colors">
                    –°–æ–∑–¥–∞—Ç—å —Å–æ–±—ã—Ç–∏–µ
                </button>
            </div>
        </div>

        <!-- Filters -->
        <div class="glass rounded-2xl p-6 mb-6">
            <div class="grid grid-cols-1 md:grid-cols-5 gap-4">
                <input type="text" id="searchBox" 
                       placeholder="üîç –ü–æ–∏—Å–∫..." 
                       oninput="filterPosts()"
                       class="md:col-span-2 px-4 py-3 rounded-xl border border-gray-200 focus:border-blue-400 focus:outline-none bg-white/70">
                
                <select id="filterCity" onchange="filterPosts()" class="px-4 py-3 rounded-xl border border-gray-200 focus:border-blue-400 focus:outline-none bg-white/70">
                    <option value="">–í—Å–µ –≥–æ—Ä–æ–¥–∞</option>
                    <option value="moscow">–ú–æ—Å–∫–≤–∞</option>
                    <option value="spb">–°–ü–±</option>
                    <option value="ekb">–ï–∫–∞—Ç–µ—Ä–∏–Ω–±—É—Ä–≥</option>
                    <option value="nsk">–ù–æ–≤–æ—Å–∏–±–∏—Ä—Å–∫</option>
                    <option value="other">–î—Ä—É–≥–æ–π</option>
                </select>
                
                <select id="filterType" onchange="filterPosts()" class="px-4 py-3 rounded-xl border border-gray-200 focus:border-blue-400 focus:outline-none bg-white/70">
                    <option value="">–í—Å–µ —Ç–∏–ø—ã</option>
                    <option value="event">–°–æ–±—ã—Ç–∏—è</option>
                    <option value="meet">–í—Å—Ç—Ä–µ—á–∏</option>
                    <option value="help">–ü–æ–º–æ—â—å</option>
                    <option value="sale">–ü—Ä–æ–¥–∞–∂–∞</option>
                    <option value="other">–î—Ä—É–≥–æ–µ</option>
                </select>
                
                <select id="filterSort" onchange="filterPosts()" class="px-4 py-3 rounded-xl border border-gray-200 focus:border-blue-400 focus:outline-none bg-white/70">
                    <option value="new">–ù–æ–≤—ã–µ</option>
                    <option value="old">–°—Ç–∞—Ä—ã–µ</option>
                    <option value="liked">–ü–æ –ª–∞–π–∫–∞–º</option>
                    <option value="my">–ú–æ–∏</option>
                    <option value="favorites">–ò–∑–±—Ä–∞–Ω–Ω–æ–µ</option>
                    <option value="hidden">–°–∫—Ä—ã—Ç—ã–µ</option>
                </select>
            </div>
            
            <button onclick="resetFilters()" 
                    class="mt-4 bg-gray-500 hover:bg-gray-600 text-white font-medium py-2 px-4 rounded-lg transition-colors">
                –°–±—Ä–æ—Å–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä—ã
            </button>
        </div>

        <!-- Posts Feed -->
        <div id="postsFeed">
            <div class="glass rounded-2xl p-8 text-center">
                <div class="text-6xl mb-4">üöÄ</div>
                <p class="text-gray-600">–°–æ–∑–¥–∞–π—Ç–µ –ø–µ—Ä–≤—ã–π –ø–æ—Å—Ç –∏–ª–∏ –¥–æ–∂–¥–∏—Ç–µ—Å—å –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ —Å–µ—Ç–∏!</p>
            </div>
        </div>
    </div>

    <script>
        // CRDT –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö
        class CRDT {
            constructor() {
                this.state = new Map();
                this.vectorClock = new Map();
                this.nodeId = this.generateNodeId();
            }

            generateNodeId() {
                return 'node_' + Math.random().toString(36).substr(2, 9) + Date.now().toString(36);
            }

            update(key, value, timestamp = Date.now()) {
                const currentClock = this.vectorClock.get(this.nodeId) || 0;
                this.vectorClock.set(this.nodeId, Math.max(currentClock, timestamp));
                
                const entry = {
                    value,
                    timestamp,
                    nodeId: this.nodeId,
                    vectorClock: new Map(this.vectorClock)
                };

                if (!this.state.has(key) || this.shouldUpdate(this.state.get(key), entry)) {
                    this.state.set(key, entry);
                    return true;
                }
                return false;
            }

            shouldUpdate(existing, incoming) {
                if (incoming.timestamp > existing.timestamp) return true;
                if (incoming.timestamp === existing.timestamp) {
                    return incoming.nodeId > existing.nodeId; // –î–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤
                }
                return false;
            }

            merge(otherState) {
                let updated = false;
                for (const [key, entry] of otherState) {
                    if (!this.state.has(key) || this.shouldUpdate(this.state.get(key), entry)) {
                        this.state.set(key, entry);
                        updated = true;
                    }
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º vector clock
                    const incomingClock = entry.vectorClock.get(entry.nodeId) || 0;
                    const currentClock = this.vectorClock.get(entry.nodeId) || 0;
                    this.vectorClock.set(entry.nodeId, Math.max(currentClock, incomingClock));
                }
                return updated;
            }

            get(key) {
                const entry = this.state.get(key);
                return entry ? entry.value : undefined;
            }

            getAll() {
                const result = new Map();
                for (const [key, entry] of this.state) {
                    result.set(key, entry.value);
                }
                return result;
            }

            serialize() {
                return JSON.stringify([...this.state], (key, value) => {
                    if (value instanceof Map) {
                        return [...value];
                    }
                    return value;
                });
            }

            deserialize(data) {
                const parsed = JSON.parse(data, (key, value) => {
                    if (Array.isArray(value) && value.length === 2 && typeof value[0] === 'string') {
                        return new Map(value);
                    }
                    return value;
                });
                return new Map(parsed);
            }
        }

        // WebRTC P2P Network
        class P2PNetwork {
            constructor() {
                this.peers = new Map();
                this.connections = new Map();
                this.rtcConnections = new Map(); // –î–ª—è WebRTC —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
                this.myId = this.generateId();
                this.crdt = new CRDT();
                this.userActions = new Map();
                this.isConnected = false;
                this.isOnline = navigator.onLine;
                this.signalingSocket = null;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                this.iceServers = [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'turn:openrelay.metered.ca:80', username: 'openrelayproject', credential: 'openrelayproject' }
                ];
                
                this.initNetwork();
                this.loadFromStorage();
                this.startCleanupTimer();
                this.registerServiceWorker();
                this.setupNetworkEventListeners();
            }

            generateId() {
                return 'peer_' + Math.random().toString(36).substr(2, 9) + Date.now().toString(36);
            }

            async registerServiceWorker() {
                if ('serviceWorker' in navigator) {
                    try {
                        const registration = await navigator.serviceWorker.register('./sw.js');
                        console.log('Service Worker –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω:', registration.scope);
                        
                        // –°–ª—É—à–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è –æ—Ç Service Worker
                        navigator.serviceWorker.addEventListener('message', event => {
                            if (event.data.type === 'SYNC_COMPLETE') {
                                console.log('–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω–æ –ø–æ—Å—Ç–æ–≤:', event.data.posts);
                                this.updateStatus('–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞');
                                renderPosts();
                            }
                        });
                        
                        // –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º —Ñ–æ–Ω–æ–≤—É—é —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—é –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –ø–æ—Å—Ç–∞
                        if ('sync' in window.ServiceWorkerRegistration.prototype) {
                            registration.sync.register('sync-posts');
                        }
                        
                    } catch (error) {
                        console.error('–û—à–∏–±–∫–∞ Service Worker:', error);
                        // Fallback: —Å–æ–∑–¥–∞–µ–º Service Worker —á–µ—Ä–µ–∑ blob
                        await this.registerFallbackServiceWorker();
                    }
                } else {
                    console.log('Service Worker –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è');
                }
            }

            async registerFallbackServiceWorker() {
                const swCode = `
                    const CACHE_NAME = 'p2p-social-fallback-v1';
                    const urlsToCache = ['/'];

                    self.addEventListener('install', event => {
                        event.waitUntil(
                            caches.open(CACHE_NAME)
                                .then(cache => cache.addAll(urlsToCache))
                        );
                    });

                    self.addEventListener('fetch', event => {
                        event.respondWith(
                            caches.match(event.request)
                                .then(response => response || fetch(event.request))
                        );
                    });
                `;
                const blob = new Blob([swCode], { type: 'application/javascript' });
                const registration = await navigator.serviceWorker.register(URL.createObjectURL(blob));
                console.log('Fallback Service Worker –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω');
            }

            async initNetwork() {
                try {
                    this.updateStatus('–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ signaling —Å–µ—Ä–≤–µ—Ä—É...');
                    
                    // –ü—ã—Ç–∞–µ–º—Å—è –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ —Ä–µ–∞–ª—å–Ω–æ–º—É signaling —Å–µ—Ä–≤–µ—Ä—É
                    await this.connectToSignalingServer();
                    
                } catch (error) {
                    console.error('Network error:', error);
                    this.updateStatus('–†–∞–±–æ—Ç–∞–µ–º –ª–æ–∫–∞–ª—å–Ω–æ');
                    this.isConnected = false;
                    this.startLocalMode();
                }
            }

            async connectToSignalingServer() {
                return new Promise((resolve, reject) => {
                    try {
                        // –ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ –≤–∞—à–µ–º—É bootstrap signaling —Å–µ—Ä–≤–µ—Ä—É
                        // –ó–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã–π URL –ø–æ—Å–ª–µ –¥–µ–ø–ª–æ—è
                        const signalingUrl = 'ws://localhost:8080'; // –î–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–π —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏
                        // const signalingUrl = 'wss://your-signaling-server.herokuapp.com'; // –î–ª—è production
                        
                        this.signalingSocket = new WebSocket(signalingUrl);
                        
                        this.signalingSocket.onopen = () => {
                            console.log('üîó Bootstrap signaling –ø–æ–¥–∫–ª—é—á–µ–Ω');
                            this.isConnected = true;
                            this.updateStatus('–ü–æ–¥–∫–ª—é—á–µ–Ω –∫ —Å–µ—Ç–∏');
                            this.reconnectAttempts = 0;
                            
                            // –ê–Ω–æ–Ω—Å–∏—Ä—É–µ–º —Å–µ–±—è –≤ —Å–µ—Ç–∏
                            this.announcePresence();
                            resolve();
                        };

                        this.signalingSocket.onmessage = async (event) => {
                            try {
                                const message = JSON.parse(event.data);
                                
                                // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
                                if (message.from === this.myId) {
                                    return;
                                }
                                
                                // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ —Å–æ–æ–±—â–µ–Ω–∏—è –∞–¥—Ä–µ—Å–æ–≤–∞–Ω–Ω—ã–µ –Ω–∞–º –∏–ª–∏ broadcast
                                if (!message.target || message.target === this.myId || message.target === 'all') {
                                    await this.handleSignalingMessage(message);
                                }
                            } catch (error) {
                                console.error('‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ signaling —Å–æ–æ–±—â–µ–Ω–∏—è:', error);
                            }
                        };

                        this.signalingSocket.onclose = () => {
                            console.log('‚ùå Signaling —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ');
                            this.isConnected = false;
                            this.updateStatus('–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –ø–æ—Ç–µ—Ä—è–Ω–æ');
                            
                            // –ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —Å —ç–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–π –∑–∞–¥–µ—Ä–∂–∫–æ–π
                            if (this.reconnectAttempts < this.maxReconnectAttempts && this.isOnline) {
                                const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);
                                this.reconnectAttempts++;
                                
                                console.log(`üîÑ –ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —á–µ—Ä–µ–∑ ${delay}ms (–ø–æ–ø—ã—Ç–∫–∞ ${this.reconnectAttempts})`);
                                setTimeout(() => this.connectToSignalingServer(), delay);
                            } else {
                                this.updateStatus('–ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –Ω–µ —É–¥–∞–ª–æ—Å—å');
                                this.startLocalMode();
                            }
                        };

                        this.signalingSocket.onerror = (error) => {
                            console.error('‚ö†Ô∏è Signaling –æ—à–∏–±–∫–∞:', error);
                            reject(error);
                        };

                        // –¢–∞–π–º–∞—É—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
                        setTimeout(() => {
                            if (this.signalingSocket.readyState !== WebSocket.OPEN) {
                                console.log('‚è∞ Timeout –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ signaling —Å–µ—Ä–≤–µ—Ä—É');
                                this.signalingSocket.close();
                                reject(new Error('Connection timeout'));
                            }
                        }, 10000);

                    } catch (error) {
                        reject(error);
                    }
                });
            }

            startLocalMode() {
                // –†–µ–∂–∏–º —Ä–∞–±–æ—Ç—ã –±–µ–∑ —Å–µ—Ç–∏ - —Ç–æ–ª—å–∫–æ –ª–æ–∫–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
                setTimeout(() => {
                    this.updateStatus('–õ–æ–∫–∞–ª—å–Ω—ã–π —Ä–µ–∂–∏–º');
                    this.broadcastMyData();
                    // –ò–º–∏—Ç–∏—Ä—É–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ –ª–æ–∫–∞–ª—å–Ω—ã—Ö "–ø–∏—Ä–æ–≤" –¥–ª—è –¥–µ–º–æ
                    this.simulateLocalPeers();
                }, 1000);
            }

            simulateLocalPeers() {
                // –°–æ–∑–¥–∞–µ–º –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã—Ö –ø–∏—Ä–æ–≤ –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏
                const demoUsers = [
                    { name: '–ê–ª–µ–∫—Å–µ–π', city: 'moscow' },
                    { name: '–ú–∞—Ä–∏—è', city: 'spb' },
                    { name: '–î–º–∏—Ç—Ä–∏–π', city: 'ekb' }
                ];

                demoUsers.forEach((user, index) => {
                    const peerId = `demo_${user.name}_${index}`;
                    this.peers.set(peerId, {
                        id: peerId,
                        name: user.name,
                        connected: true,
                        lastSeen: Date.now()
                    });

                    // –°–æ–∑–¥–∞–µ–º –¥–µ–º–æ-–ø–æ—Å—Ç—ã –æ—Ç –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
                    if (Math.random() > 0.5) {
                        const demoPost = {
                            id: this.generateId(),
                            author: peerId,
                            authorName: user.name,
                            timestamp: Date.now() - Math.random() * 86400000, // –ü–æ—Å–ª–µ–¥–Ω–∏–µ 24 —á–∞—Å–∞
                            expiresAt: Date.now() + (7 * 24 * 60 * 60 * 1000),
                            title: this.generateDemoTitle(),
                            description: this.generateDemoDescription(),
                            city: user.city,
                            type: ['event', 'meet', 'help'][Math.floor(Math.random() * 3)],
                            tags: this.generateDemoTags(),
                            likes: Math.floor(Math.random() * 10),
                            likedBy: [],
                            reports: { illegal: 0, provocation: 0, advertisement: 0 }
                        };
                        
                        this.crdt.update(demoPost.id, demoPost, demoPost.timestamp);
                    }
                });

                this.updatePeerCount();
                renderPosts();
            }

            generateDemoTitle() {
                const titles = [
                    '–í—Å—Ç—Ä–µ—á–∞ –ª—é–±–∏—Ç–µ–ª–µ–π –∫–æ—Ñ–µ',
                    '–ö–æ–Ω—Ü–µ—Ä—Ç –Ω–∞ –∫—Ä—ã—à–µ',
                    '–ò–∑—É—á–∞–µ–º JavaScript –≤–º–µ—Å—Ç–µ',
                    '–§–æ—Ç–æ—Å–µ—Å—Å–∏—è –≤ –ø–∞—Ä–∫–µ',
                    '–í–æ–ª–æ–Ω—Ç–µ—Ä—Å—Ç–≤–æ –≤ –ø—Ä–∏—é—Ç–µ',
                    '–ù–∞—Å—Ç–æ–ª—å–Ω—ã–µ –∏–≥—Ä—ã –ø–æ –≤—ã—Ö–æ–¥–Ω—ã–º',
                    '–í–µ–ª–æ–ø—Ä–æ–≥—É–ª–∫–∞ –ø–æ –≥–æ—Ä–æ–¥—É',
                    '–ú–∞—Å—Ç–µ—Ä-–∫–ª–∞—Å—Å –ø–æ –≥–æ—Ç–æ–≤–∫–µ'
                ];
                return titles[Math.floor(Math.random() * titles.length)];
            }

            generateDemoDescription() {
                const descriptions = [
                    '–ü—Ä–∏–≥–ª–∞—à–∞—é –≤—Å–µ—Ö –∂–µ–ª–∞—é—â–∏—Ö –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è –∫ –Ω–∞—à–µ–º—É –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—é!',
                    '–ë—É–¥–µ—Ç –∏–Ω—Ç–µ—Ä–µ—Å–Ω–æ –∏ –≤–µ—Å–µ–ª–æ, –ø—Ä–∏—Ö–æ–¥–∏—Ç–µ!',
                    '–î–∞–≤–∞–π—Ç–µ –≤–º–µ—Å—Ç–µ –ø—Ä–æ–≤–µ–¥–µ–º –≤—Ä–µ–º—è —Å –ø–æ–ª—å–∑–æ–π.',
                    '–ò—â—É –µ–¥–∏–Ω–æ–º—ã—à–ª–µ–Ω–Ω–∏–∫–æ–≤ –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–Ω–æ–≥–æ –≤—Ä–µ–º—è–ø—Ä–µ–ø—Ä–æ–≤–æ–∂–¥–µ–Ω–∏—è.',
                    '–û—Ç–ª–∏—á–Ω–∞—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –ø–æ–∑–Ω–∞–∫–æ–º–∏—Ç—å—Å—è —Å –Ω–æ–≤—ã–º–∏ –ª—é–¥—å–º–∏.',
                    '–í—Å–µ —É—Ä–æ–≤–Ω–∏ –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤—É—é—Ç—Å—è!'
                ];
                return descriptions[Math.floor(Math.random() * descriptions.length)];
            }

            generateDemoTags() {
                const allTags = ['–º—É–∑—ã–∫–∞', '—Å–ø–æ—Ä—Ç', 'IT', '—Ñ–æ—Ç–æ', '–ø—Ä–∏—Ä–æ–¥–∞', '–¥—Ä—É–∂–±–∞', '—É—á–µ–±–∞', '—Ä–∞–∑–≤–ª–µ—á–µ–Ω–∏—è'];
                const count = Math.floor(Math.random() * 3) + 1;
                return allTags.sort(() => 0.5 - Math.random()).slice(0, count);
            }

            announcePresence() {
                if (this.signalingSocket && this.signalingSocket.readyState === WebSocket.OPEN) {
                    const announcement = {
                        type: 'announce',
                        peerId: this.myId,
                        timestamp: Date.now()
                    };
                    this.signalingSocket.send(JSON.stringify(announcement));
                }
            }

            async handleSignalingMessage(message) {
                console.log(`üì® –ü–æ–ª—É—á–µ–Ω–æ signaling —Å–æ–æ–±—â–µ–Ω–∏–µ: ${message.type} –æ—Ç ${message.from}`);
                
                switch (message.type) {
                    case 'announce':
                        if (message.peerId !== this.myId) {
                            console.log(`üëã –ù–æ–≤—ã–π –ø–∏—Ä –≤ —Å–µ—Ç–∏: ${message.peerId}`);
                            // –ò–Ω–∏—Ü–∏–∏—Ä—É–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–∞—à ID –±–æ–ª—å—à–µ (–∏–∑–±–µ–≥–∞–µ–º –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è)
                            if (this.myId > message.peerId) {
                                setTimeout(() => {
                                    this.connectToPeer(message.peerId);
                                }, Math.random() * 2000); // –°–ª—É—á–∞–π–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞
                            }
                        }
                        break;
                    case 'offer':
                        await this.handleOffer(message);
                        break;
                    case 'answer':
                        await this.handleAnswer(message);
                        break;
                    case 'ice-candidate':
                        await this.handleIceCandidate(message);
                        break;
                    default:
                        console.log(`‚ùì –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø signaling —Å–æ–æ–±—â–µ–Ω–∏—è: ${message.type}`);
                }
            }

            async connectToPeer(peerId) {
                if (this.connections.has(peerId) || this.rtcConnections.has(peerId)) {
                    console.log(`üîÑ –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å ${peerId} —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç`);
                    return;
                }

                try {
                    console.log(`ü§ù –ò–Ω–∏—Ü–∏–∏—Ä—É–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å –ø–∏—Ä–æ–º: ${peerId}`);
                    const connection = await this.createRTCConnection(peerId);
                    
                    // –°–æ–∑–¥–∞–µ–º offer
                    const offer = await connection.createOffer({
                        offerToReceiveAudio: false,
                        offerToReceiveVideo: false
                    });
                    await connection.setLocalDescription(offer);

                    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º offer —á–µ—Ä–µ–∑ signaling —Å–µ—Ä–≤–µ—Ä
                    this.sendSignalingMessage({
                        type: 'offer',
                        target: peerId,
                        offer: offer
                    });

                    console.log(`üì§ Offer –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –ø–∏—Ä—É: ${peerId}`);

                } catch (error) {
                    console.error(`‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –ø–∏—Ä—É ${peerId}:`, error);
                    this.handlePeerDisconnection(peerId);
                }
            }

            async handleOffer(message) {
                try {
                    console.log(`üì• –ü–æ–ª—É—á–µ–Ω offer –æ—Ç ${message.from}`);
                    const connection = await this.createRTCConnection(message.from);
                    
                    await connection.setRemoteDescription(new RTCSessionDescription(message.offer));
                    const answer = await connection.createAnswer();
                    await connection.setLocalDescription(answer);

                    this.sendSignalingMessage({
                        type: 'answer',
                        target: message.from,
                        answer: answer
                    });

                    console.log(`üì§ Answer –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –ø–∏—Ä—É: ${message.from}`);

                } catch (error) {
                    console.error(`‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ offer –æ—Ç ${message.from}:`, error);
                }
            }

            async handleAnswer(message) {
                try {
                    console.log(`üì• –ü–æ–ª—É—á–µ–Ω answer –æ—Ç ${message.from}`);
                    const connection = this.rtcConnections.get(message.from);
                    if (connection) {
                        await connection.setRemoteDescription(new RTCSessionDescription(message.answer));
                        console.log(`‚úÖ Answer –æ–±—Ä–∞–±–æ—Ç–∞–Ω –æ—Ç ${message.from}`);
                    } else {
                        console.warn(`‚ö†Ô∏è RTC —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –¥–ª—è ${message.from}`);
                    }
                } catch (error) {
                    console.error(`‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ answer –æ—Ç ${message.from}:`, error);
                }
            }

            async handleIceCandidate(message) {
                try {
                    const connection = this.rtcConnections.get(message.from);
                    if (connection && message.candidate) {
                        await connection.addIceCandidate(new RTCIceCandidate(message.candidate));
                        console.log(`üßä ICE candidate –¥–æ–±–∞–≤–ª–µ–Ω –æ—Ç ${message.from}`);
                    }
                } catch (error) {
                    console.error(`‚ùå –û—à–∏–±–∫–∞ ICE candidate –æ—Ç ${message.from}:`, error);
                }
            }

            sendSignalingMessage(message) {
                if (this.signalingSocket && this.signalingSocket.readyState === WebSocket.OPEN) {
                    this.signalingSocket.send(JSON.stringify(message));
                }
            }

            setupNetworkEventListeners() {
                // –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å–µ—Ç–∏
                window.addEventListener('online', () => {
                    this.isOnline = true;
                    this.updateStatus('–°–µ—Ç—å –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞');
                    this.reconnectAttempts = 0;
                    this.initNetwork();
                });

                window.addEventListener('offline', () => {
                    this.isOnline = false;
                    this.isConnected = false;
                    this.updateStatus('–†–∞–±–æ—Ç–∞–µ–º –æ—Ñ–ª–∞–π–Ω');
                    this.closeAllConnections();
                });

                // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–∫—Ä—ã—Ç–∏—è —Å—Ç—Ä–∞–Ω–∏—Ü—ã
                window.addEventListener('beforeunload', () => {
                    this.disconnect();
                });

                // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–æ–∫—É—Å–∞/–ø–æ—Ç–µ—Ä–∏ —Ñ–æ–∫—É—Å–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        console.log('–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ —Å–∫—Ä—ã—Ç–æ');
                    } else {
                        console.log('–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω–æ');
                        if (this.isOnline && !this.isConnected) {
                            this.initNetwork();
                        }
                    }
                });
            }

            closeAllConnections() {
                // –ó–∞–∫—Ä—ã–≤–∞–µ–º –≤—Å–µ WebRTC —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
                for (const [peerId, connection] of this.rtcConnections) {
                    connection.close();
                }
                this.rtcConnections.clear();
                
                // –ó–∞–∫—Ä—ã–≤–∞–µ–º data channels
                for (const [peerId, channel] of this.connections) {
                    channel.close();
                }
                this.connections.clear();
                
                // –ó–∞–∫—Ä—ã–≤–∞–µ–º signaling —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
                if (this.signalingSocket) {
                    this.signalingSocket.close();
                    this.signalingSocket = null;
                }
                
                this.peers.clear();
                this.updatePeerCount();
            }

            disconnect() {
                this.closeAllConnections();
                this.isConnected = false;
                this.updateStatus('–û—Ç–∫–ª—é—á–µ–Ω');
            }

            async createRTCConnection(peerId) {
                if (this.rtcConnections.has(peerId)) {
                    return this.rtcConnections.get(peerId);
                }

                const connection = new RTCPeerConnection({ iceServers: this.iceServers });
                this.rtcConnections.set(peerId, connection);
                
                // –°–æ–∑–¥–∞–µ–º data channel –¥–ª—è –ø–æ—Å—Ç–æ–≤
                const dataChannel = connection.createDataChannel('posts', {
                    ordered: true,
                    maxRetransmits: 3
                });

                this.setupDataChannel(dataChannel, peerId);
                
                // –û–±—Ä–∞–±–æ—Ç–∫–∞ incoming data channels
                connection.ondatachannel = (event) => {
                    this.setupDataChannel(event.channel, peerId);
                };

                // ICE candidate handling
                connection.onicecandidate = (event) => {
                    if (event.candidate) {
                        this.sendSignalingMessage({
                            type: 'ice-candidate',
                            target: peerId,
                            from: this.myId,
                            candidate: event.candidate
                        });
                    }
                };

                // Connection state monitoring
                connection.onconnectionstatechange = () => {
                    console.log(`RTC Connection state with ${peerId}: ${connection.connectionState}`);
                    
                    if (connection.connectionState === 'connected') {
                        this.peers.set(peerId, {
                            id: peerId,
                            connected: true,
                            lastSeen: Date.now()
                        });
                        this.updatePeerCount();
                    } else if (connection.connectionState === 'failed' || connection.connectionState === 'disconnected') {
                        this.handlePeerDisconnection(peerId);
                    }
                };

                connection.oniceconnectionstatechange = () => {
                    console.log(`ICE Connection state with ${peerId}: ${connection.iceConnectionState}`);
                };

                return connection;
            }

            setupDataChannel(dataChannel, peerId) {
                dataChannel.onopen = () => {
                    console.log(`Data channel –æ—Ç–∫—Ä—ã—Ç —Å ${peerId}`);
                    this.connections.set(peerId, dataChannel);
                    
                    // –°—Ä–∞–∑—É –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—é
                    this.sendToPeer(peerId, {
                        type: 'sync',
                        data: this.crdt.serialize()
                    });
                };

                dataChannel.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        this.handlePeerMessage(peerId, message);
                    } catch (error) {
                        console.error('–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –æ—Ç –ø–∏—Ä–∞:', error);
                    }
                };

                dataChannel.onclose = () => {
                    console.log(`Data channel –∑–∞–∫—Ä—ã—Ç —Å ${peerId}`);
                    this.handlePeerDisconnection(peerId);
                };

                dataChannel.onerror = (error) => {
                    console.error(`–û—à–∏–±–∫–∞ data channel —Å ${peerId}:`, error);
                };
            }

            handlePeerDisconnection(peerId) {
                this.connections.delete(peerId);
                this.peers.delete(peerId);
                
                const rtcConnection = this.rtcConnections.get(peerId);
                if (rtcConnection) {
                    rtcConnection.close();
                    this.rtcConnections.delete(peerId);
                }
                
                this.updatePeerCount();
                console.log(`–ü–∏—Ä ${peerId} –æ—Ç–∫–ª—é—á–µ–Ω`);
            }

            sendToPeer(peerId, message) {
                const dataChannel = this.connections.get(peerId);
                if (dataChannel && dataChannel.readyState === 'open') {
                    try {
                        dataChannel.send(JSON.stringify(message));
                        return true;
                    } catch (error) {
                        console.error(`–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–∏—Ä—É ${peerId}:`, error);
                        return false;
                    }
                }
                return false;
            }

            handlePeerMessage(peerId, message) {
                switch (message.type) {
                    case 'sync':
                        this.handleSync(peerId, message.data);
                        break;
                    case 'post':
                        this.handleNewPost(peerId, message.data);
                        break;
                    case 'like':
                        this.handleLike(peerId, message.data);
                        break;
                    case 'report':
                        this.handleReport(peerId, message.data);
                        break;
                    default:
                        console.log('–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø —Å–æ–æ–±—â–µ–Ω–∏—è:', message.type);
                }
            }

            handleSync(fromPeerId, syncData) {
                try {
                    const remoteState = this.crdt.deserialize(syncData);
                    const updated = this.crdt.merge(remoteState);
                    
                    if (updated) {
                        console.log(`–ü–æ–ª—É—á–µ–Ω–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –æ—Ç ${fromPeerId}, –æ–±–Ω–æ–≤–ª–µ–Ω–æ –∑–∞–ø–∏—Å–µ–π`);
                        this.saveToStorage();
                        renderPosts();
                        this.updatePeerCount();
                        
                        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ–±—Ä–∞—Ç–Ω—É—é —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—é –µ—Å–ª–∏ –µ—Å—Ç—å –Ω–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
                        this.sendToPeer(fromPeerId, {
                            type: 'sync-response',
                            data: this.crdt.serialize()
                        });
                    }
                } catch (error) {
                    console.error('–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏:', error);
                }
            }

            handleNewPost(fromPeerId, postData) {
                try {
                    if (this.crdt.update(postData.id, postData, postData.timestamp)) {
                        console.log(`–ù–æ–≤—ã–π –ø–æ—Å—Ç –æ—Ç ${fromPeerId}: ${postData.title}`);
                        this.saveToStorage();
                        renderPosts();
                        this.updatePeerCount();
                        
                        // –¢—Ä–∞–Ω—Å–ª–∏—Ä—É–µ–º –Ω–æ–≤—ã–π –ø–æ—Å—Ç –¥—Ä—É–≥–∏–º –ø–∏—Ä–∞–º (–∏—Å–∫–ª—é—á–∞—è –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è)
                        this.relayMessage(fromPeerId, {
                            type: 'post',
                            data: postData
                        });
                    }
                } catch (error) {
                    console.error('–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –Ω–æ–≤–æ–≥–æ –ø–æ—Å—Ç–∞:', error);
                }
            }

            handleLike(fromPeerId, likeData) {
                try {
                    const post = this.crdt.get(likeData.postId);
                    if (post) {
                        let updated = false;
                        
                        if (likeData.action === 'like') {
                            if (!post.likedBy.includes(likeData.userId)) {
                                post.likes = (post.likes || 0) + 1;
                                post.likedBy = post.likedBy || [];
                                post.likedBy.push(likeData.userId);
                                updated = true;
                            }
                        } else if (likeData.action === 'unlike') {
                            if (post.likedBy.includes(likeData.userId)) {
                                post.likes = Math.max(0, (post.likes || 0) - 1);
                                post.likedBy = post.likedBy.filter(id => id !== likeData.userId);
                                updated = true;
                            }
                        }
                        
                        if (updated) {
                            this.crdt.update(post.id, post);
                            this.saveToStorage();
                            renderPosts();
                            
                            // –¢—Ä–∞–Ω—Å–ª–∏—Ä—É–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏–µ –¥—Ä—É–≥–∏–º –ø–∏—Ä–∞–º
                            this.relayMessage(fromPeerId, {
                                type: 'like',
                                data: likeData
                            });
                        }
                    }
                } catch (error) {
                    console.error('–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ª–∞–π–∫–∞:', error);
                }
            }

            handleReport(fromPeerId, reportData) {
                try {
                    const post = this.crdt.get(reportData.postId);
                    if (post) {
                        post.reports = post.reports || { illegal: 0, provocation: 0, advertisement: 0 };
                        post.reports[reportData.reportType] = (post.reports[reportData.reportType] || 0) + 1;
                        
                        if (post.reports[reportData.reportType] >= 10) {
                            post.flagged = reportData.reportType;
                        }

                        this.crdt.update(post.id, post);
                        this.saveToStorage();
                        renderPosts();
                        
                        // –¢—Ä–∞–Ω—Å–ª–∏—Ä—É–µ–º –∂–∞–ª–æ–±—É –¥—Ä—É–≥–∏–º –ø–∏—Ä–∞–º
                        this.relayMessage(fromPeerId, {
                            type: 'report',
                            data: reportData
                        });
                    }
                } catch (error) {
                    console.error('–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∂–∞–ª–æ–±—ã:', error);
                }
            }

            relayMessage(excludePeerId, message) {
                // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –≤—Å–µ–º –ø–∏—Ä–∞–º –∫—Ä–æ–º–µ –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è
                for (const [peerId, channel] of this.connections) {
                    if (peerId !== excludePeerId && channel.readyState === 'open') {
                        this.sendToPeer(peerId, message);
                    }
                }
            }

            broadcast(message) {
                let successCount = 0;
                let totalPeers = this.connections.size;
                
                for (const [peerId, channel] of this.connections) {
                    if (this.sendToPeer(peerId, message)) {
                        successCount++;
                    }
                }
                
                console.log(`–°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ ${successCount}/${totalPeers} –ø–∏—Ä–∞–º`);
                return successCount;
            }

            broadcastMyData() {
                if (this.connections.size > 0) {
                    const syncMessage = {
                        type: 'sync',
                        data: this.crdt.serialize()
                    };
                    this.broadcast(syncMessage);
                } else {
                    console.log('–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏');
                }
            }

            async createPost(postData) {
                const post = {
                    id: this.generateId(),
                    author: this.myId,
                    timestamp: Date.now(),
                    expiresAt: Date.now() + (7 * 24 * 60 * 60 * 1000),
                    ...postData,
                    likes: 0,
                    likedBy: [],
                    reports: { illegal: 0, provocation: 0, advertisement: 0 }
                };

                post.signature = await this.signPost(post);
                
                this.crdt.update(post.id, post);
                this.saveToStorage();
                
                // –£–≤–µ–¥–æ–º–ª—è–µ–º –ø–∏—Ä–æ–≤
                this.broadcast({
                    type: 'post',
                    data: post
                });
                
                return post;
            }

            async signPost(post) {
                if (window.crypto && window.crypto.subtle) {
                    try {
                        const encoder = new TextEncoder();
                        const data = encoder.encode(JSON.stringify({
                            author: post.author,
                            title: post.title,
                            description: post.description,
                            timestamp: post.timestamp
                        }));
                        
                        const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                        const hashArray = Array.from(new Uint8Array(hashBuffer));
                        return hashArray.map(b => b.toString(16).padStart(2, '0')).join('').slice(0, 16);
                    } catch (error) {
                        console.error('Crypto signing error:', error);
                    }
                }
                
                // Fallback –¥–ª—è —Å—Ç–∞—Ä—ã—Ö –±—Ä–∞—É–∑–µ—Ä–æ–≤
                return btoa(JSON.stringify({
                    author: post.author,
                    title: post.title,
                    timestamp: post.timestamp
                })).slice(0, 16);
            }

            likePost(postId) {
                const post = this.crdt.get(postId);
                if (!post) return;

                const userActions = this.getUserActions(postId);
                const action = userActions.liked ? 'unlike' : 'like';
                
                if (action === 'like') {
                    post.likes = (post.likes || 0) + 1;
                    post.likedBy = post.likedBy || [];
                    if (!post.likedBy.includes(this.myId)) {
                        post.likedBy.push(this.myId);
                    }
                    userActions.liked = true;
                } else {
                    post.likes = Math.max(0, (post.likes || 0) - 1);
                    post.likedBy = (post.likedBy || []).filter(id => id !== this.myId);
                    userActions.liked = false;
                }

                this.crdt.update(postId, post);
                this.saveUserAction(postId, userActions);
                this.saveToStorage();

                // –£–≤–µ–¥–æ–º–ª—è–µ–º –ø–∏—Ä–æ–≤
                this.broadcast({
                    type: 'like',
                    data: {
                        postId,
                        userId: this.myId,
                        action
                    }
                });
            }

            reportPost(postId, type) {
                const post = this.crdt.get(postId);
                if (!post) return;

                post.reports[type] = (post.reports[type] || 0) + 1;
                
                if (post.reports[type] >= 10) {
                    post.flagged = type;
                }

                this.crdt.update(postId, post);
                this.saveToStorage();
                
                this.broadcast({
                    type: 'report',
                    data: {
                        postId,
                        reportType: type,
                        userId: this.myId
                    }
                });
            }

            getUserActions(postId) {
                if (!this.userActions.has(postId)) {
                    this.userActions.set(postId, {
                        liked: false,
                        hidden: false,
                        favorite: false
                    });
                }
                return this.userActions.get(postId);
            }

            saveUserAction(postId, actions) {
                this.userActions.set(postId, actions);
                localStorage.setItem('p2p_user_actions', JSON.stringify([...this.userActions]));
            }

            hidePost(postId) {
                const userActions = this.getUserActions(postId);
                userActions.hidden = !userActions.hidden;
                this.saveUserAction(postId, userActions);
            }

            favoritePost(postId) {
                const userActions = this.getUserActions(postId);
                userActions.favorite = !userActions.favorite;
                this.saveUserAction(postId, userActions);
            }

            getAllPosts() {
                const posts = [];
                for (const [id, post] of this.crdt.getAll()) {
                    if (post.expiresAt > Date.now()) {
                        posts.push(post);
                    }
                }
                return posts;
            }

            getMyPosts() {
                return this.getAllPosts().filter(post => post.author === this.myId);
            }

            updateStatus(text) {
                document.getElementById('statusText').textContent = text;
                const statusDot = document.getElementById('statusDot');
                statusDot.className = `w-2 h-2 rounded-full status-dot ${this.isConnected ? 'bg-green-500' : 'bg-red-500'}`;
                this.updatePeerCount();
            }

            updatePeerCount() {
                document.getElementById('peerCount').textContent = `–ü–∏—Ä–æ–≤: ${this.peers.size}`;
                document.getElementById('postCount').textContent = `–ü–æ—Å—Ç–æ–≤: ${this.getAllPosts().length}`;
            }

            saveToStorage() {
                localStorage.setItem('p2p_crdt_state', this.crdt.serialize());
                localStorage.setItem('p2p_my_id', this.myId);
            }

            loadFromStorage() {
                const savedState = localStorage.getItem('p2p_crdt_state');
                if (savedState) {
                    const state = this.crdt.deserialize(savedState);
                    this.crdt.merge(state);
                }

                const savedId = localStorage.getItem('p2p_my_id');
                if (savedId) {
                    this.myId = savedId;
                }

                const savedActions = localStorage.getItem('p2p_user_actions');
                if (savedActions) {
                    this.userActions = new Map(JSON.parse(savedActions));
                }
            }

            startCleanupTimer() {
                setInterval(() => {
                    const now = Date.now();
                    let cleaned = false;
                    
                    for (const [id, post] of this.crdt.getAll()) {
                        if (post.expiresAt <= now) {
                            if (post.author === this.myId) {
                                post.status = 'draft';
                                post.note = '–ü–æ—Å—Ç –∏—Å—Ç–µ–∫ (7 –¥–Ω–µ–π)';
                                this.crdt.update(id, post);
                            }
                            cleaned = true;
                        }
                    }
                    
                    if (cleaned) {
                        this.saveToStorage();
                        renderPosts();
                        this.updatePeerCount();
                    }
                }, 10 * 60 * 1000);
            }
        }

        // –ì–ª–æ–±–∞–ª—å–Ω–∞—è —Å–µ—Ç—å
        const network = new P2PNetwork();

        // UI —Ñ—É–Ω–∫—Ü–∏–∏
        async function createPost() {
            const title = document.getElementById('postTitle').value.trim();
            const description = document.getElementById('postDescription').value.trim();
            
            if (!title || !description) {
                alert('–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –∑–∞–≥–æ–ª–æ–≤–æ–∫ –∏ –æ–ø–∏—Å–∞–Ω–∏–µ');
                return;
            }

            const postData = {
                title,
                description,
                tags: document.getElementById('postTags').value.split(',').map(t => t.trim()).filter(t => t),
                contacts: document.getElementById('postContacts').value.trim(),
                city: document.getElementById('postCity').value,
                type: document.getElementById('postType').value,
                gender: document.getElementById('postGender').value,
                age: document.getElementById('postAge').value
            };

            await network.createPost(postData);
            
            // –û—á–∏—â–∞–µ–º —Ñ–æ—Ä–º—É
            document.getElementById('postTitle').value = '';
            document.getElementById('postDescription').value = '';
            document.getElementById('postTags').value = '';
            document.getElementById('postContacts').value = '';
            
            renderPosts();
            network.updatePeerCount();
        }

        function renderPosts() {
            const container = document.getElementById('postsFeed');
            let posts = getFilteredPosts();
            
            if (posts.length === 0) {
                container.innerHTML = `
                    <div class="glass rounded-2xl p-8 text-center">
                        <div class="text-6xl mb-4">üì≠</div>
                        <p class="text-gray-600">–ü–æ—Å—Ç–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ</p>
                    </div>
                `;
                return;
            }

            container.innerHTML = posts.map(post => {
                const userActions = network.getUserActions(post.id);
                const isMyPost = post.author === network.myId;
                const timeLeft = Math.max(0, post.expiresAt - Date.now());
                const daysLeft = Math.ceil(timeLeft / (24 * 60 * 60 * 1000));
                
                return `
                    <div class="glass rounded-2xl p-6 mb-4">
                        ${post.flagged ? `
                            <div class="bg-yellow-100 border border-yellow-400 text-yellow-800 px-4 py-2 rounded-lg mb-4">
                                ‚ö†Ô∏è –ü–æ—Å—Ç –ø–æ–º–µ—á–µ–Ω: ${getReportTypeName(post.flagged)}
                            </div>
                        ` : ''}
                        
                        <div class="flex justify-between items-start mb-3">
                            <div class="text-sm text-gray-600">
                                ${isMyPost ? 'üë§ –í–∞—à –ø–æ—Å—Ç' : 'üë• –£—á–∞—Å—Ç–Ω–∏–∫ —Å–µ—Ç–∏'} ‚Ä¢ 
                                ${new Date(post.timestamp).toLocaleDateString()} ‚Ä¢ 
                                ‚è±Ô∏è ${daysLeft}–¥
                                ${post.city ? ` ‚Ä¢ üìç ${getCityName(post.city)}` : ''}
                                ${post.type ? ` ‚Ä¢ üè∑Ô∏è ${getTypeName(post.type)}` : ''}
                            </div>
                        </div>
                        
                        <h3 class="text-xl font-semibold text-gray-800 mb-2">${escapeHtml(post.title)}</h3>
                        <p class="text-gray-700 mb-4 leading-relaxed">${escapeHtml(post.description)}</p>
                        
                        ${post.tags && post.tags.length > 0 ? `
                            <div class="flex flex-wrap gap-2 mb-4">
                                ${post.tags.map(tag => `
                                    <span class="px-3 py-1 bg-blue-100 text-blue-800 text-sm rounded-full">#${escapeHtml(tag)}</span>
                                `).join('')}
                            </div>
                        ` : ''}
                        
                        ${post.contacts ? `
                            <div class="bg-gray-50 rounded-lg p-3 mb-4">
                                <div class="text-sm text-gray-600 mb-1">–ö–æ–Ω—Ç–∞–∫—Ç—ã:</div>
                                <div class="text-gray-800">${escapeHtml(post.contacts)}</div>
                            </div>
                        ` : ''}
                        
                        <div class="flex flex-wrap gap-2 items-center">
                            <button onclick="likePost('${post.id}')" 
                                    class="flex items-center gap-2 px-3 py-2 rounded-lg transition-colors ${userActions.liked ? 'bg-red-100 text-red-700' : 'bg-gray-100 hover:bg-gray-200 text-gray-700'}">
                                ${userActions.liked ? '‚ù§Ô∏è' : 'ü§ç'} ${post.likes || 0}
                            </button>
                            
                            <button onclick="favoritePost('${post.id}')" 
                                    class="px-3 py-2 rounded-lg transition-colors ${userActions.favorite ? 'bg-yellow-100 text-yellow-700' : 'bg-gray-100 hover:bg-gray-200 text-gray-700'}">
                                ${userActions.favorite ? '‚≠ê' : '‚òÜ'}
                            </button>
                            
                            <button onclick="hidePost('${post.id}')" 
                                    class="px-3 py-2 rounded-lg bg-gray-100 hover:bg-gray-200 text-gray-700 transition-colors">
                                ${userActions.hidden ? 'üëÅÔ∏è' : 'üôà'}
                            </button>
                            
                            ${!isMyPost ? `
                                <div class="relative">
                                    <button onclick="toggleReportMenu('${post.id}')" 
                                            class="px-3 py-2 rounded-lg bg-red-100 hover:bg-red-200 text-red-700 transition-colors">
                                        üö©
                                    </button>
                                    <div class="absolute right-0 top-full mt-1 bg-white rounded-lg shadow-lg border hidden z-10" id="reportMenu_${post.id}">
                                        <button onclick="reportPost('${post.id}', 'illegal')" 
                                                class="block w-full text-left px-4 py-2 hover:bg-gray-50 text-sm">–ù–µ–∑–∞–∫–æ–Ω–Ω–æ</button>
                                        <button onclick="reportPost('${post.id}', 'provocation')" 
                                                class="block w-full text-left px-4 py-2 hover:bg-gray-50 text-sm">–ü—Ä–æ–≤–æ–∫–∞—Ü–∏—è</button>
                                        <button onclick="reportPost('${post.id}', 'advertisement')" 
                                                class="block w-full text-left px-4 py-2 hover:bg-gray-50 text-sm">–†–µ–∫–ª–∞–º–∞</button>
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function getFilteredPosts() {
            let posts = network.getAllPosts();
            const search = document.getElementById('searchBox').value.toLowerCase();
            const cityFilter = document.getElementById('filterCity').value;
            const typeFilter = document.getElementById('filterType').value;
            const sortFilter = document.getElementById('filterSort').value;

            // –ü–æ–∏—Å–∫
            if (search) {
                posts = posts.filter(post => 
                    post.title.toLowerCase().includes(search) ||
                    post.description.toLowerCase().includes(search) ||
                    (post.tags && post.tags.some(tag => tag.toLowerCase().includes(search)))
                );
            }

            // –§–∏–ª—å—Ç—Ä—ã
            if (cityFilter) {
                posts = posts.filter(post => post.city === cityFilter);
            }
            
            if (typeFilter) {
                posts = posts.filter(post => post.type === typeFilter);
            }

            // –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –∏ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã
            switch (sortFilter) {
                case 'my':
                    posts = posts.filter(post => post.author === network.myId);
                    break;
                case 'favorites':
                    posts = posts.filter(post => network.getUserActions(post.id).favorite);
                    break;
                case 'hidden':
                    posts = posts.filter(post => network.getUserActions(post.id).hidden);
                    break;
                case 'liked':
                    posts.sort((a, b) => (b.likes || 0) - (a.likes || 0));
                    break;
                case 'old':
                    posts.sort((a, b) => a.timestamp - b.timestamp);
                    break;
                default: // 'new'
                    posts.sort((a, b) => b.timestamp - a.timestamp);
            }

            return posts;
        }

        function filterPosts() {
            renderPosts();
        }

        function resetFilters() {
            document.getElementById('searchBox').value = '';
            document.getElementById('filterCity').value = '';
            document.getElementById('filterType').value = '';
            document.getElementById('filterSort').value = 'new';
            renderPosts();
        }

        function likePost(postId) {
            network.likePost(postId);
            renderPosts();
        }

        function hidePost(postId) {
            network.hidePost(postId);
            renderPosts();
        }

        function favoritePost(postId) {
            network.favoritePost(postId);
            renderPosts();
        }

        function reportPost(postId, type) {
            network.reportPost(postId, type);
            document.getElementById(`reportMenu_${postId}`).classList.add('hidden');
            alert('–ñ–∞–ª–æ–±–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞');
            renderPosts();
        }

        function toggleReportMenu(postId) {
            const menu = document.getElementById(`reportMenu_${postId}`);
            menu.classList.toggle('hidden');
            
            // –ó–∞–∫—Ä—ã–≤–∞–µ–º –¥—Ä—É–≥–∏–µ –º–µ–Ω—é
            document.querySelectorAll('[id^="reportMenu_"]').forEach(dropdown => {
                if (dropdown.id !== `reportMenu_${postId}`) {
                    dropdown.classList.add('hidden');
                }
            });
        }

        function getCityName(city) {
            const cities = {
                'moscow': '–ú–æ—Å–∫–≤–∞',
                'spb': '–°–ü–±',
                'ekb': '–ï–∫–∞—Ç–µ—Ä–∏–Ω–±—É—Ä–≥',
                'nsk': '–ù–æ–≤–æ—Å–∏–±–∏—Ä—Å–∫',
                'other': '–î—Ä—É–≥–æ–π'
            };
            return cities[city] || city;
        }

        function getTypeName(type) {
            const types = {
                'event': '–°–æ–±—ã—Ç–∏–µ',
                'meet': '–í—Å—Ç—Ä–µ—á–∞',
                'help': '–ü–æ–º–æ—â—å',
                'sale': '–ü—Ä–æ–¥–∞–∂–∞',
                'other': '–î—Ä—É–≥–æ–µ'
            };
            return types[type] || type;
        }

        function getReportTypeName(type) {
            const reportTypes = {
                'illegal': '–ù–µ–∑–∞–∫–æ–Ω–Ω—ã–π –∫–æ–Ω—Ç–µ–Ω—Ç',
                'provocation': '–ü—Ä–æ–≤–æ–∫–∞—Ü–∏—è',
                'advertisement': '–†–µ–∫–ª–∞–º–∞'
            };
            return reportTypes[type] || type;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // –ó–∞–∫—Ä—ã—Ç–∏–µ –º–µ–Ω—é –ø–æ –∫–ª–∏–∫—É –≤–Ω–µ
        document.addEventListener('click', (e) => {
            if (!e.target.closest('[id^="reportMenu_"]') && !e.target.closest('button')) {
                document.querySelectorAll('[id^="reportMenu_"]').forEach(dropdown => {
                    dropdown.classList.add('hidden');
                });
            }
        });

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        renderPosts();
        
        // –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ
        setInterval(() => {
            renderPosts();
            network.updatePeerCount();
        }, 30000);

        // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Å –ø–∏—Ä–∞–º–∏ –∫–∞–∂–¥—ã–µ 10 —Å–µ–∫—É–Ω–¥
        setInterval(() => {
            if (network.isConnected) {
                network.broadcastMyData();
            }
        }, 10000);
    </script>
</body>
</html>
